CHAPTER 2: Creating and Destorying Objects

Item 1 : Consider static factory methods instead of constructors
 Advantages:
 1. static factory methods have names
 2. static factory methods are not required to create new object each time they're invoked
 3. static factory methods can return an object of any subtype of their return type
 4. static factory methods reduce the verbosity of creating parameterized type instances
    Map<String, List<String>> m = HashMap.newInstance();

 Disadvantages:
 1. classes without public or protected constructors cannot be subclassed
 2. They are not really distinguishable from other static methods
    valueOf
    getInstance
    newInstance

Item 2 : Consider a builder when faced with many constructor parameters
  1. Telescoping constructor pattern, in which you provide a constructor with only the required paramters, another with a single optional parameters, a third with two optional parameters and so on  --->>> Does Not Scale Well 
     It's hard to write client code when there are many parameters, and harder still to read it.
  2. JavaBeans Pattern Disadvantage:
     1) may be in an inconsistent state partway through its construction
     2) precludes the possibility of making the class immutable
  3. Builder Pattern

Item 3 : Enforce the singleton property with a private constructor or an enum type
  1. Making a class a singleton can make it difficult to test its clients
  2. A single-element enum type is the best way to implement a singleton

Item 4 : Enforce noninstantiability with a private constructor
  1. a class can be made noninstantiable by including a private constructor
  2. As a side effect, this idiom also prevents the class from being subclassed. All constructors must invoke a superclass constructor, explicitly or implicitly, and a subclass would have no accessible superclass constructor to invoke

Item 5 : Avoid creating unnecessary objects
  1. String s = new String("stradafa"); // Don't do this   
     String s = "dfafafas";    
  2. Prefer primitives to boxed primitives, and watch out for untentional autoboxing
     public static void main() {
         Long sum = 0L; /// better to use long
         for (long i = 0; i < Integer.Max_VALUE; i++) {
             sum += i;
     }

Item 6: Eliminate obsolete object references
  1. Whenever a class manages its own memory, the programmer should be alert for memory leaks
  2. Another comman source of memory leaks is caches
  3. A third common source of memory leaks is listerneres and other callbacks

Item 7: Avoid finalizers
  1. never do anything time-critical in a finalizer
  2. there is a severe performance penalty for using finalizers 

CHAPTER 3 Methods Common to All Objects

Item 8: Obey the general contract when overriding equals
  1. Not to override the equals method
     1) Each instance of the class is inherently unique
     2) You don't care whether the class provides a "logical equality" test
     3) A superclass has already overridden equals, and the superclass behavior is appropriate for this class
     4) The class is private or package-priavte, and you are cerntain that its equals method will never be invoked
  2. When is it appropriate to override Object.equals?
     When a class has a notion of logical equality that differs from mere object identity, and a superclass has not already overridden equals to implement the desired behavior. This     is generally the case for value classes.
  3. When you override the equals method, you must adhere to its general contract: Reflexive, Symmetric, Transitivie, Consistent
  4. There is no way to extand an instantiable class and add a value component while preserving the equals contract, this is a fundamental problem of equivalence relations in OO lan     guanges. Workaround is composition over inheritance

Item 9: Always override hashCode when you override equals
  1. The key provision that is violated when you fail to override hashCode is the second one: equal objects must have equal hash codes
  2. Do not be tempted to exclude significant parts of an object from the hash code computation to improve performance

Item 10: Alaways override toString
  1. Providing a good toString implementation makes your class much more pleasant to use
  2. When practical, the toString method should return all of the interesting information contained in the object
  3. Whether or not you decide to specify the format, you should clearly document your intentions.

Item 11: Override clone judiciously
  1. Normally, implementing an interface says sth about what a class can do for its clients. In the case of Cloneable, it modifies the behavior of a protected method on a superclass.
  2. If you override the clone method in a nonfinal class, you should return an object obtained by invoking super.clone
  3. In effect, the clone method functions as another constructor; you must ensure that it does no harm to the original object and that it properly establishes invariants on the clone
  4. The clone architecture is incompatible with normal use of final fields referring to mutable objects
  5. A fine approach to object copying is to provide a copy constructor or copy factory.

Item 12: Consider implementing Comparable
  1. If sorting of objects needs to be based on natural order then use Comparable, if sorting needs to be done on attribute of different objects, then use Comparator 
  2. If you don't have control over a class(or you want to provide multiple ways to compare objects that you do have control over), then use Comparator.

Item 13: Minimize the accessibility of classes and members
  1. Information hiding or encapsulation
  2. Rule of thumb: make each class or member as inaccessible as possible

Item 14: In public class, use accessor methods, not public fields
  1. If a class is accessible outside of its package, provide accessor methods

Item 15: Minimize mutability
  1. Immutable objects are simple
  2. Immutable objects are inherently thread-safe; they require no synchronization
  3. Immutable objects can be shared freely
  4. The only real disadvantage of immutable classes is thay they require a spearate object for each distinct value 
  5. Classes should be immutable unless there's a very good reason to make them mutable
  6. If a class can't be made immutable, limit its mutabliity as much as possible.
  7. Make every field final unless there is a compelling reason to make it nonfinal, like cache the results of expensive computations the first time they are needed

Item 16: Favor composition over inheritance
  1. To avoid this fragility, use composition and forwarding instead of inheritance, especially if an appropriate interface to implement a wrapper class exists. Not only are wrapper classes more robust than subclasses, they are also more powerful.

Item 17: Design and document for inheritance or else prohibit it
  1. Class must document its self-use of overrideable methods
  2. The only way to test a class designed for inheritance it to write subclasses, you must test your class by writing subclasses before you release it
  3. Constructors must not invoke overridable methods

Item 18: Prefer interfaces to abstract classes
  1. Existing classes can be easily retrofitted to implement a new interface
  2. Interfaces allow the construction of nonhierarchical type frameworks
  3. Interfaces enable safe, powerfull functionality enhancements
  4. You can combine the virtues of interfaces and abstract classes by providing an abstract skeletal implementation class to go with each nontrivial interface that you export

Item 19: Use interfaces only to define types
  1. The constant interface pattern is a poor use of interfaces

Item 20: Prefer class hierarchies to tagged classes
  1. Tagged classes are verbose, error-prone and inefficient

Item 21: Use function objects to represent strategies
  1. A primary use of function pointers is to implement the Strategy pattern. To implement in Java, declare an interface to represrent the strategy, and a class that implements this interface for each concrete strategy. When a concrete strategy is used only once, it's typicially declared and instantiated as an anonymous class. When a concrete strategy is designed for repeated use, it's generally implemented as a private static memeber class and exported in a public static final field whose type is the strategy interface

Item 22: Favor static member classes over nonstatic
  1. If you declare a member class that does not require access to an enclosing instance, always put the static modifier in its declaration
  2. There are four kinds of nested classes: static member classes, nonstatic member classes, anonymous classes and local classes

Item 23: Don't use raw types in new code
  1. If you use raw types, you lose all the safety and expressiveness benefits of generics
  2. You lose type safety if you use a raw type like List, but not if you use a parameterized type like List<Object>
  3. You can't put any element(other than null) into a Collection<?>
  4. Two exceptions: class literals(List<String>.class is not legal) and instanceof operator

Item 24: Eliminate unchecked warnings
  1. Eliminate every unchecked warning that you can
  3. If  you can't eliminate a warning and you can prove that the code that provoked the warning is typesafe, then suppress the warning with @SuppressWarnings annotation

Item 25: Prefer lists to arrays
  1. Arrays and generics do not mix well
  2. Array provide runtime type safety but not compile-time type safety and vice versa for generics.

Item 26: Favor generic types
  1. Object type in collections are good candidate to replace with generic types
  2. new E[] cause compile time error, use (E[] new Object[]) instead

Item 27: Favor generic methods
  1. Static utility methods are particularly good candidates for generification
  2. The type parameter list, which declares the type parameter, goes between the method's modifiers and its return type(public static <K, V> void method())
  3. Generic methods could type inference of arguments

Item 28: Use bounded wildcards to increase API flexibility
  1. Generics are invariant(List<Integer> is not a subtype of List<Number>)
  2. For maximum flexibility, use wildcard types on input parameters that represent producers or consumers
  3. PECS stands for producer-extends, consumer-super
  4. Producer: add(List<? extends Number>)
  5. Consumer: get(List<? super Number>)
  6. Do not use wildcard types as return types
  7. Comparable and Comparator are consumers

Item 29: Consider typesafe heterogeneous containers
  1. You can use Class objects as keys for such typesafe heterogeneous containers

Item 30: Use enums instead of int constants
  1. Int enum patterns has many shortcomings, it provides nothing in the way of type safety and little in the way of convenience
  2. Enums provide complie-time type safety
  3. Each enum internally is public static final int field
  4. You can add/reorder constants in a enum type without recompiling clients
  5. To associate data with enum constants, declare instance fields and write a constructor that takes the data and stores it in the fields
  6. If an enum is generally useful, it should be a top-level class; if its use is tied to a specific top-level class, it should be a member class of that top-level class
  7. To avoid switch on enum constant, we can use constant-specific method implementations, which declare an abstract apply method in the enum type and override it with a concrete method
  8. In some cases, overriding toString in an enum is very useful
  9. Enum types have an automatically generated valueOf(String) method that translates a constant's name into the constant itself
  10. Use strategy enum pattern to share code among enum constants
  11. Switches on enums are good for augmenting external enum types with constant-specific behavior

Item 31: Useinstancefieldsinsteadofordinals
  1. Many enums are naturally associated with a single int value
  2. All enums have an ordinal method, which returns the numerical position of each enum constant in its type.
  3. Never derive a value associated with an enum from its ordinal; store it in an instance field instead
     public enum Ensemble {
         SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),
         SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8),
         NONET(9), DECTET(10), TRIPLE_QUARTET(12);
         private final int numberOfMusicians;
         Ensemble(int size) { this.numberOfMusicians = size; } 
         public int numberOfMusicians() { return numberOfMusicians; }
     }

Item 32: Use EnumSet instead of bit fields
  1. just because an enumerated type will be used in sets, there is no reason to represent it with bit fields
  2. The EnumSet class combines the con- ciseness and performance of bit fields with all the many advantages of enum types

Item 33: Use EnumMap instead of ordinal indexing
  1. it is rarely appropriate to use ordinals to index arrays: use EnumMap instead

Item 34: Emulate extensible enums with interfaces
  1. For the most part, extensibility of enums turns out to be a bad idea
  2. while you cannot write an extensible enum type, you can emulate it by writing an interface to go with a basic enum type that imple- ments the interface.

Item 35: Prefer annotations to naming patterns
  1. More generally, annotations never change the semantics of the annotated code, but enable it for special treatment by tools
  2. There is simply no reason to use naming patterns now that we have annotations.
  3. All programmers should, however, use the pre- defined annotation types provided by the Java platform

Item 36: Consistently use the Override annotation
  1. use the Override annotation on every method decla- ration that you believe to override a superclass declaration

Item 37: Use marker interfaces to define types
  1. A marker interface is an interface that contains no method declarations
  2. marker interface vs marker annotation
  3. marker interfaces define a type that is implemented by instances of the marked class; marker annotations do not
  4. Marker interfaces can be targeted more precisely by extending that interface
  5. The chief advantage of marker annotations over marker interfaces is that it is possible to add more information to an annotation type after it is already in use, by adding one or more annotation type elements with defaults (Java8 default methods)

Item 38: Check parameters for validity
  1. Fail fast
  2. For public methods, use the Javadoc @throws tag to document the exception that will be thrown if a restriction on parameter values is violated
  3. nonpublic methods should generally check their parameters using assertions
  4. Do not use validity check if it is impractical or performed implicitly in the process of doing the computation
